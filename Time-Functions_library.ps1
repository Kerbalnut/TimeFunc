<#
.SYNOPSIS
  <Overview of script>

.DESCRIPTION
  <Brief description of script>

.PARAMETER -SampleParam
  <This parameter text will not be shown, since -SampleParam is not a real parameter listed in Param(). However, if a .PARAMETER help line is present and there is no Param(), all help text will fail.>

.PARAMETER LaunchedInCmd
  Used to indicate to this script when it has been launched in a Command Prompt windows (CMD.EXE)
  
  Formats output to the size of a standard Command Prompt (79 characters wide + 1) or to the size of a standard PowerShell window (119 characters winde + 1)

.PARAMETER LoadFunctions
  Use this switch to only load the functions in this script. The script main body execution will not run.

.INPUTS
  <Inputs if any, otherwise state None>

.OUTPUTS 
Log File
  The script log file stored in C:\Windows\Temp\<name>.log

.NOTES
  Version:        1.0
  Author:         <Name>
  Creation Date:  <Date>
  Purpose/Change: Initial script development

  Requires PSLogging module from 
  https://9to5it.com/powershell-logging-v2-easily-create-log-files/
  PowerShell Gallery:
  https://www.powershellgallery.com/packages/PSLogging/
  GitHub:
  https://www.powershellgallery.com/packages/PSLogging/

  AUTOGENERATED CONTENT
    The name, syntax, parameter list, parameter attribute table, common
    parameters, and remarks are automatically generated by the Get-Help cmdlet.

.EXAMPLE
  <Example explanation goes here>
  
  <Example goes here. Repeat this attribute for more than one example>

.LINK
about_Comment_Based_Help

.LINK
about_Requires

.LINK
about_Scripts

.LINK
https://ss64.com/ps/syntax-run.html

.LINK
https://ss64.com/ps/call.html

.LINK
about_Functions_CmdletBindingAttribute
#>

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------#Requires-------------------------------------------------------

# "#Requires" - You can use a #Requires statement to prevent a script from running without specified modules or snap-ins and a specified version of PowerShell. For more information, see about_Requires.
# help about_Requires
# help about_PSSnapins
# e.g. "#Requires -Version 6" "#Requires -RunAsAdministrator"
#Requires -Modules PSLogging

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#1. PSLogging module
<#
# To insatll PSLogging module:
# https://docs.microsoft.com/en-us/powershell/developer/module/installing-a-powershell-module
# PowerShell v4:
# 	1. Find PSModulePath environment variable
# 		$Env:PSModulePath
# 		[Environment]::GetEnvironmentVariable("PSModulePath")
#	2. Find the PSLogging module
# 		.\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging
# 	3. Either copy the module to a location within the PSModulePath environment variable, or add the location of the module to the PSModulePath environment variable.
# 		3a. Copy the module to the location:
# 			# Install for Current User - $Home\Documents\WindowsPowerShell\Modules (%UserProfile%\Documents\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Home\Documents\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 			# Install for All Users - $Env:ProgramFiles\WindowsPowerShell\Modules (%ProgramFiles%\WindowsPowerShell\Modules)
# 				$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 				$Destination = "$Env:ProgramFiles\WindowsPowerShell\Modules"
# 				Copy-Item "$newModule" -Destination "$Destination\PSLogging" -Recurse
# 		3b. Add the module's path to the PSModulePath environment variable
# 			$newModule = ".\PowerShell\Templates\9to5it\PSLogging-master\Module\PSLogging"
# 			$p = [Environment]::GetEnvironmentVariable("PSModulePath")
# 			$p += ";$newModule"
# 			[Environment]::SetEnvironmentVariable("PSModulePath",$p)
# PowerShell v5: (and above)
# 	Find-Module -Name "PSLogging*" | Install-Module -Scope AllUsers 
# Accepted values: CurrentUser, AllUsers
# 	Update-Module PSLogging -Force
#>

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Header]--------------------------------------------------------

#Index:
#1. <# .HELP #>
#2. #Requires
#3. [Header]
#4. [Script Parameters]
#5. [Initializations]
#6. [Modules]
#7. [Declarations]
#8. [Functions]
#9. [Execution]
#10. [Footer]

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Run this script:
<#
# Tested with PowerShell versions:
# 5.1
# Get PowerShell version:
# $PSVersionTable.PSVersion

# To run from PowerShell command line:
# https://ss64.com/ps/syntax-run.html
# https://ss64.com/ps/syntax-scriptblock.html
# When passing a variable to a scriptblock it is important to consider the variable scope.
#    Each time the scriptblock is run; it will dynamically read the current value of the variable.
#    When a scriptblock is run using the "." (dot) operator, updates to a variable apply to the current scope.
#    When a scriptblock is run using the "&" (call) operator, updates to a variable are not reflected in the parent scope.
# help about_Scripts
# %USERPROFILE% = $env:UserProfile = $Home
# 'Dot-sourcing:'
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\Convert-TimeValues.ps1"
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\Convert-TimeValues.ps1" -Verbose -Debug
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\Convert-TimeValues.ps1" -Verbose -Debug -LaunchedInCmd
# . "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\Convert-TimeValues.ps1" -LoadFunctions
# https://ss64.com/ps/source.html
# Using the 'call' operator (&):
# & "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\Convert-TimeValues.ps1"
# & "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\Convert-TimeValues.ps1" -Verbose -Debug
# & "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\Convert-TimeValues.ps1" -Verbose -Debug -LaunchedInCmd
# https://ss64.com/ps/call.html

# To run help:
# Get-Help "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\Convert-TimeValues.ps1"
# Get-Help "$env:UserProfile\Documents\GitHub\Batch-Tools-SysAdmin\PowerShell\Convert-TimeValues.ps1" -Full
# Example help file:
# Get-Help Get-ChildItem
# Get-Help Get-ChildItem -Full

# Execution Policy:
# $oldExecutionPolicy = Get-ExecutionPolicy
# Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
# Set-ExecutionPolicy -ExecutionPolicy Bypass
# Set-ExecutionPolicy $oldExecutionPolicy
#>

#-----------------------------------------------------------------------------------------------------------------------
#--------------------------------------------------[Script Parameters]--------------------------------------------------

# Debugging: absolutely NO commands can come before Param (except for [CmdletBinding()] )
# Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
# https://ss64.com/ps/syntax-args.html

#[CmdletBinding()]
#[CmdletBinding(SupportsShouldProcess=$true)]

#Script parameters go here
Param (
  #Script parameters go here
  # Debugging: You must have a script parameter defined here if you have the Help Topic .PARAMETER defined above.
  # help about_Functions_Advanced_Parameters
  # https://ss64.com/ps/syntax-args.html
  # https://ss64.com/ps/syntax-automatic-variables.html

  [Parameter(Mandatory=$false)]
  [switch]$LaunchedInCmd = $false,

  [Parameter(Mandatory=$false)]
  [switch]$LoadFunctions = $false
)

#-----------------------------------------------------------------------------------------------------------------------
#---------------------------------------------------[Initializations]---------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Initializations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Script name (including extension)
$ScriptName = $MyInvocation.MyCommand.Name
Write-Verbose "Script name:"
Write-Verbose "$ScriptName"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script dir (home directory of script)
Write-Verbose "Script home directory:"
#https://stackoverflow.com/questions/801967/how-can-i-find-the-source-path-of-an-executing-script/6985381#6985381
$ScriptDir = Split-Path $script:MyInvocation.MyCommand.Path
Write-Verbose "$ScriptDir"
$ScriptDir = Split-Path -parent $MyInvocation.MyCommand.Definition # PoSh v2 compatible - thanks to https://stackoverflow.com/questions/5466329/whats-the-best-way-to-determine-the-location-of-the-current-powershell-script
Write-Verbose "$ScriptDir"
$ScriptDir = $PSScriptRoot # PoSh v3 compatible - This is an automatic variable set to the current file's/module's directory
Write-Verbose "$ScriptDir"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

# Script path (full file path & name & extension of currently running script)
$ScriptPath = $MyInvocation.MyCommand.Path
Write-Verbose "Script full path:"
Write-Verbose "$ScriptPath"
Write-Verbose `r`n # New line (carriage return and newline (CRLF), `r`n)

#Set Error Action to Silently Continue
$ErrorActionPreference = 'SilentlyContinue'
#Set Error Action to Continue
$ErrorActionPreference = 'Continue'

#Set Verbose message display
#$VerbosePreference = "SilentlyContinue"
#$VerbosePreference = "Continue"

#Set Debug message display
# help about_Debuggers
#$DebugPreference = "SilentlyContinue"
#$DebugPreference = "Continue"

#Set Progress Bar display
#* If the progress bar does not appear, check the value of the $ProgressPreference variable. If the value is set to SilentlyContinue, the progress bar is not displayed. For more information about Windows PowerShell preferences, see about_Preference_Variables.
#$ProgressPreference = "SilentlyContinue"
#$ProgressPreference = "Continue"

#Set Informational message display
#$InformationPreference = "SilentlyContinue"
#$InformationPreference = "Continue"

#Check Execution Policy
$RecommendedExecutionPolicy = "RemoteSigned"
Write-Verbose "Recommended Execution Policy = $RecommendedExecutionPolicy"
#Write-Host "Current Execution Policy =" (Get-ExecutionPolicy)
$startExecutionPolicy = Get-ExecutionPolicy
Write-Verbose "Current Execution Policy = $startExecutionPolicy"

#Check PowerShell version
$MinimumRequiredVersion = 6
# https://ss64.com/ps/get-host.html
# https://stackoverflow.com/questions/1825585/determine-installed-powershell-version
$PoShVersion = $PSVersionTable.PSVersion
Write-Verbose "Minimum required PowerShell version = $MinimumRequiredVersion"
Write-Verbose "Current PowerShell version = $($PSVersionTable.PSVersion.Major).$($PSVersionTable.PSVersion.Minor)"
# https://ss64.com/ps/if.html
IF ($PSVersionTable.PSVersion.Major -lt $MinimumRequiredVersion) {
    Write-Warning "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
	Write-Debug "This script requires at least PowerShell version $MinimumRequiredVersion. Running version $PoShVersion"
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Initializations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#-------------------------------------------------------[Modules]-------------------------------------------------------

#Import Modules & Snap-ins
Write-Verbose "Importing modules..."
Write-Verbose `n # New line (carriage return and newline, `r`n)

Import-Module PSLogging

Write-Verbose `r`n
Write-Verbose "Module import complete..."

#-----------------------------------------------------------------------------------------------------------------------
#-----------------------------------------------------[Declarations]----------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Skip [Declarations] script block if -LoadFunctions is on.
If (-Not $LoadFunctions) {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#Script Version
$sScriptVersion = '1.0'

#Log File Info
$sLogPath = $ScriptDir
$yesterday = [DateTime]::Today.AddDays(-1)
$TodaysDate = Get-Date -Format FileDate
Write-Verbose "Date code = $TodaysDate"
$sLogName = $MyInvocation.MyCommand.Name.Substring(0,$MyInvocation.MyCommand.Name.Length-4) + "_" + $TodaysDate + ".log"
Write-Verbose "LogName = $sLogName"
$sLogFile = Join-Path -Path $sLogPath -ChildPath $sLogName
Write-Verbose "LogFile = $sLogFile"

# Create Log file if we don't have one already
If (!($sLogPath)) { Start-Log -LogPath $sLogPath -LogName $sLogName -ScriptVersion $sScriptVersion }

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}
# Skip [Declarations] script block if -LoadFunctions is on.
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Functions]------------------------------------------------------

# help about_Functions
# help about_Functions_Advanced
# help about_Functions_Advanced_Methods
# help about_Functions_Advanced_Parameters
# Get-Verb

#Index of functions:
#1. Write-HorizontalRule
#2. Write-HorizontalRuleAdv

Function Write-HorizontalRule {
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0)]
    [string]$HRtype = 'SingleLine'
  )
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd -eq $true) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
	# Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      Write-Host ===============================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host -------------------------------------------------------------------------------- # This too long
      Write-Host -------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  } ELSEIF ($LaunchedInCmd -eq $false) {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      Write-Host =======================================================================================================================
    } ELSEIF ($HRtype -eq "DashedLine") {
      Write-Host - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    } ELSEIF ($HRtype -eq "SingleLine") {
      #Write-Host ------------------------------------------------------------------------------------------------------------------------ # This too long
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSEIF (-Not $HRtype) {
      Write-Host -----------------------------------------------------------------------------------------------------------------------
    } ELSE {
      Write-Verbose "PowerShell Script launched in cmd.exe = $LaunchedInCmd"
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
    }
  }
} # End Write-HorizontalRule function ----------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

Function Write-HorizontalRuleAdv {
  <#
	.SYNOPSIS
	Writes a horizontal rule across the the console. 
	
	.DESCRIPTION
	Writes either a horzintal rule of different types:
	
	SingleLine "-----" (default)
	DoubleLine "====="
	DashedLine "- - -"
	BlankLine  "     "
	
	Using different output types:
	
	using Write-Host (default)
	"--------------"
	
	using Write-Warning
	"WARNING: -----"
	
	using Write-Verbose
	"VERBOSE: -----"
	
	.PARAMETER HRtype
	Horizontal Rule types. Accepted types are 'SingleLine', 'DoubleLine', 'DashedLine', and 'BlankLine'. Defaults to 'SingleLine'.
	
	.PARAMETER SingleLine
	Set horizontal rule type as 'SingleLine'. If no other horizontal rule type is selected, will default to this.
	
	.PARAMETER DoubleLine
	Set horizontal rule type as 'DoubleLine'
	
	.PARAMETER DashedLine
	Set horizontal rule type as 'DashedLine'
	
	.PARAMETER BlankLine
	Set horizontal rule type as 'BlankLine'
	
	.PARAMETER Endcaps
	Add a character to each end of the horizontal rule. Default is '#'. Set a different endcap character using -EndcapCharacter <single character>
	
	.PARAMETER EndcapCharacter
	Define which character is used as the end-cap using -EndcapCharacter "<SINGLE_CHARACTER>". Only works if the -Endcaps switch is also enabled. Default is '#'. 
	
	.PARAMETER IsWarning
	Prints the output as a warning (using Write-Warning).
	
	.PARAMETER IsVerbose
	Prints the output as a verbose message (using Write-Verbose). Will only be displayed if $VerbosePreference = "Continue"
	
	.INPUTS
	If run without any input parameters, will default to a SingleLine "-----" ouput using Write-Host.
	
	.OUTPUTS
	Outputs a horizontal rule across the console of the selected type.
	
	.NOTES
	Command Prompt character width: 79
	PowerShell window character width: 119
	
	WARNING: 
	VERBOSE: 
	123456789
	
	.LINK
	about_Comment_Based_Help
	
	.LINK
	about_Functions_Advanced_Parameters
	
	.LINK
	https://docs.microsoft.com/en-us/powershell/developer/cmdlet/validating-parameter-input
	
	.LINK
	https://social.technet.microsoft.com/wiki/contents/articles/15994.powershell-advanced-function-parameter-attributes.aspx
	
	.LINK
	help about_Automatic_Variables
	
	.LINK
	help about_If
	
	.LINK
	help about_Comparison_Operators
	
  #>
  
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  Param (
    #Script parameters go here
    # https://ss64.com/ps/syntax-args.html
    [Parameter(Mandatory=$false,Position=0,
    ParameterSetName='DefineString')]
    [ValidateSet("SingleLine", "DoubleLine", "DashedLine", "BlankLine")]
    [Alias('HorizontalRule','HorizontalRuleType','Type')]
    [string]$HRtype = 'SingleLine',
    
    [Parameter(ParameterSetName='SingleLine')]
    [switch]$SingleLine,
    
    [Parameter(ParameterSetName='DoubleLine')]
    [switch]$DoubleLine,
    
    [Parameter(ParameterSetName='DashedLine')]
    [switch]$DashedLine,
    
    [Parameter(ParameterSetName='BlankLine')]
    [switch]$BlankLine,
    
    [Parameter(Mandatory=$false)]
    [switch]$Endcaps = $false,

    [Parameter(Mandatory=$false)]
    [string]$EndcapCharacter = '#',
    
    [Parameter(Mandatory=$false)]
    [switch]$IsWarning = $false,

    [Parameter(Mandatory=$false)]
    [switch]$IsVerbose = $false,

    [Parameter(Mandatory=$false)]
    [switch]$MaxLineLength = $false
  )
  
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
  # Function name:
  # https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
  #$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
  #$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
  $FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
  
  # help about_Automatic_Variables
  # help about_If
  # help about_Comparison_Operators
  # https://ss64.com/ps/if.html
  IF ($LaunchedInCmd) {
    # Print horizontal rule styles here using Write-Host instead of Write-Verbose, since that would add "VERBOSE: " to the beginning of each line and prevent the horizontal rule from lining up on the screen properly.
    # Command Prompt character width: 79
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "==============================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                               "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "--------------------------------------------------------------------------------" # This too long
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  } ELSE {
    # PowerShell window character width: 119
    IF ($HRtype -eq "DoubleLine") {
      $HRoutput = "======================================================================================================================="
    } ELSEIF ($HRtype -eq "DashedLine") {
      $HRoutput = "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
    } ELSEIF ($HRtype -eq "BlankLine") {
      $HRoutput = "                                                                                                                       "
    } ELSEIF ($HRtype -eq "SingleLine") {
      #HRoutput = "------------------------------------------------------------------------------------------------------------------------" # This too long
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSEIF (-Not $HRtype) {
      $HRoutput = "-----------------------------------------------------------------------------------------------------------------------"
    } ELSE {
      Write-Error -Message "Parameter -HRtype `"$HRtype`" not recognized."  -Category InvalidData -ErrorId HRtype
      Return
    }
  }
  
  # Command Prompt character width: 79
  # PowerShell window character width: 119
  $MaxLength = $HRoutput.Length
  
  IF ($IsWarning -eq $true -or $IsVerbose -eq $true) {
    #WARNING: 
    #VERBOSE: 
    #123456789
    $MaxLength = $MaxLength - 9
    $HRoutput = ($HRoutput).Substring(9,$MaxLength)
  }
  
  IF ($Endcaps -eq $true) {
    #$EndcapLength = $MaxLength - 2
    $MaxLength = $MaxLength - 2
    #$HRoutput = ($HRoutput).Substring(1,$EndcapLength)
    $HRoutput = ($HRoutput).Substring(1,$MaxLength)
    $HRoutput = "$EndcapCharacter$HRoutput$EndcapCharacter"
  }
  
  $MaxLineLengthOutput = $MaxLength
  
  # Write output
  
  IF ($MaxLineLength -eq $true) {
    Write-Output $MaxLineLengthOutput
  } ELSEIF ($IsWarning -eq $true) {
    Write-Warning $HRoutput -WarningAction Continue
  } ELSEIF ($IsVerbose -eq $true) {
    # Set Verbose message display
    # $VerbosePreference = "Continue"
    # $VerbosePreference = "SilentlyContinue"
    #$OrigVerbosePreference = $VerbosePreference
    #$VerbosePreference = "Continue"
    Write-Verbose $HRoutput
    #$VerbosePreference = $OrigVerbosePreference
  } ELSE {
    Write-Host $HRoutput
  }
  
  #- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  
} # End Write-HorizontalRuleAdv function -------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#https://www.powershellgallery.com/packages/Convert-Time/1.0#

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


Function Log-Time {
	<#
		.SYNOPSIS
		Log-Time

		.DESCRIPTION
		Log-Time

		.PARAMETER TimeLogFile
		TimeLogFile

		.PARAMETER TimeStampTag
		TimeStampTag

		.PARAMETER Interactive
		Interactive

		.PARAMETER ClockIn
		ClockIn

		.PARAMETER ClockOut
		ClockOut

		.PARAMETER TimeStamp
		TimeStamp

		.PARAMETER TaskStart
		TaskStart

		.PARAMETER TaskStop
		TaskStop
		
		.PARAMETER BreakStart
		BreakStart
		
		.PARAMETER BreakStop
		BreakStop
		
		.PARAMETER PauseStart
		PauseStart
		
		.PARAMETER PauseStop
		PauseStop
		
		.PARAMETER Distraction
		Distraction
		
		.EXAMPLE
		C:\PS> Test-Param -A "Anne" -D "Dave" -F "Freddy"
	#>
	Param (
		#[CmdletBinding(DefaultParameterSetName="ByUserName")]
		# Script parameters go here
		#https://ss64.com/ps/syntax-args.html
		#http://wahlnetwork.com/2017/07/10/powershell-aliases/
		#https://www.jonathanmedd.net/2013/01/add-a-parameter-to-multiple-parameter-sets-in-powershell.html
		[Parameter(Mandatory=$true,Position=0)]
		[string]$TimeLogFile = '.\TimeLog.csv', 
		
		[Parameter(Mandatory=$false)]
		[Alias('i','PickTime','Add')]
		[switch]$Interactive = $false,
		
		[Parameter(Mandatory=$false,
		Position=1,
		ParameterSetName='CustomTag')]
		[string]$TimeStampTag,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='ClockInTag')]
		[switch]$ClockIn,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='ClockOutTag')]
		[switch]$ClockOut,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='TimeStampTag')]
		[switch]$TimeStamp,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='TaskStartTag')]
		[string]$TaskStart,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='TaskStopTag')]
		[switch]$TaskStop,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='BreakStartTag')]
		[switch]$BreakStart,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='BreakStopTag')]
		[switch]$BreakStop,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='PauseStartTag')]
		[string]$PauseStart,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='PauseStopTag')]
		[switch]$PauseStop,
		
		[Parameter(Mandatory=$false,
		ParameterSetName='DistractionTag')]
		[switch]$Distraction
		
	)
	
	# Function name:
	# https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
	#$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
	#$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
	$FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
	Write-Verbose "Running function: $FunctionName"
	
	# -----------------------------------------------------------------------------------------------------------------------
	# Evaluate input parameters
	# -----------------------------------------------------------------------------------------------------------------------
	
	If (!$TimeLogFile) {
		Write-Warning "Time-Log file does not exist: '$TimeLogFile'"
        Do {
            $UserInput = Read-Hose "Would you like to create it? [Y/N]"
        } until ($UserInput -eq 'y' -Or $UserInput -eq 'n')
        If ($UserInput -eq 'y') {
            New-Item $UserInput #| Out-Null
        } else {
            Return
        }
	}
	
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	If ($TimeStampTag) {
		$TimeLogTag = $TimeStampTag
		$BeginEnd = "[TimeStamp]"
	}
	
	If ($ClockIn) {
		$TimeLogTag = "Clock-In"
		$BeginEnd = "[Begin]"
	}
	
	If ($ClockOut) {
		$TimeLogTag = "Clock-Out"
		$BeginEnd = "[End]"
	}
	
	If ($TimeStamp) {
		$TimeLogTag = "TimeStamp"
		$BeginEnd = "[TimeStamp]"
	}
	
	If ($TaskStart) {
		$TimeLogTag = "Task-Start='$TaskStart'"
		$BeginEnd = "[Begin]"
	}
	
	If ($TaskStop) {
		$TimeLogTag = "Task-Stop"
		$BeginEnd = "[End]"
	}
	
	If ($BreakStart) {
		$TimeLogTag = "Break-Start"
		$BeginEnd = "[Begin]"
	}
	
	If ($BreakStop) {
		$TimeLogTag = "Break-Stop"
		$BeginEnd = "[End]"
	}
	
	If ($PauseStart) {
		$TimeLogTag = "Pause-Start='$PauseStart'"
		$BeginEnd = "[Begin]"
	}
	
	If ($PauseStop) {
		$TimeLogTag = "Pause-Stop"
		$BeginEnd = "[End]"
	}
	
	If ($Distraction) {
		$TimeLogTag = "Distraction"
		$BeginEnd = "[TimeStamp]"
	}
	
	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	# -----------------------------------------------------------------------------------------------------------------------
	# Build Time-Log Entry
	# -----------------------------------------------------------------------------------------------------------------------
	
	
} # End Log-Time function ----------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Function Total-TimestampArray {
	
	Param (
		#Script parameters go here
		# https://ss64.com/ps/syntax-args.html
		[Parameter(Mandatory=$false,Position=0)]
		[string]$HRtype = 'SingleLine', 
		
		[Parameter(Mandatory=$false)]
		[switch]$Endcaps = $false,

		[Parameter(Mandatory=$false)]
		[string]$EndcapCharacter = '#',
		
		[Parameter(Mandatory=$false)]
		[switch]$IsWarning = $false,

		[Parameter(Mandatory=$false)]
		[switch]$IsVerbose = $false,

		[Parameter(Mandatory=$false)]
		[switch]$MaxLineLength = $false
	)
	
	# Function name:
	# https://stackoverflow.com/questions/3689543/is-there-a-way-to-retrieve-a-powershell-function-name-from-within-a-function#3690830
	#$FunctionName = (Get-PSCallStack | Select-Object FunctionName -Skip 1 -First 1).FunctionName
	#$FunctionName = (Get-Variable MyInvocation -Scope 1).Value.MyCommand.Name
	$FunctionName = $PSCmdlet.MyInvocation.MyCommand.Name
	Write-Verbose "Running function: $FunctionName"
	
	
} # End Total-TimestampArray function ---------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------------------------



#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Once [Functions] block has finished running, exit the script if -LoadFunctions switch is on.
If ($LoadFunctions) {
  #https://stackoverflow.com/questions/2022326/terminating-a-script-in-powershell
  # Only load functions of script. Do not execute Main script block.
  Return
}
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Execution]------------------------------------------------------

#=======================================================================================================================
#Index:
#1. Testing Convert-AMPMhourTo24hour
#2. User Choice Selection / Menu Demos
#3. Test For loop & date formatting
#4. Test multi-dimensional variable methods
#5. Test running external script
#=======================================================================================================================

#-----------------------------------------------------------------------------------------------------------------------
#=======================================================================================================================
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#
#
##Script MAIN Execution goes here
Clear-Host # CLS
Write-Verbose `n
Write-HorizontalRuleAdv -HRtype DoubleLine -IsVerbose
Write-Verbose `n
Write-Verbose "Script Main beginning. $ScriptName"

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#1. Testing Convert-AMPMhourTo24hour
#=======================================================================================================================

$SectionName = "#1. Testing Convert-AMPMhourTo24hour"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

<#
12.1
11.6
11.4
11
011
9.6
9.4
09
9
-9
.9
0.9
.0
0.0
#>

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

help Convert-AMPMhourTo24hour

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host "help Convert-AMPMhourTo24hour -full"
Write-Warning "Executing `"help Convert-AMPMhourTo24hour -full`" from a script environment during run will not display any of the extra information from the -Full switch. The command must be executed from the command line to get entire help content."

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 1 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 12 -AM


Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 09.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 09.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 12.1 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 11.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 11.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 11 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 011 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 9.6 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 9.4 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 009 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 09 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Success:" -ForegroundColor Green
Convert-AMPMhourTo24hour 9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour -9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour .9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0.9 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour .0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

Write-Host "Failure:"
Convert-AMPMhourTo24hour 0.0 -AM

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #1:"

$AMPMhour = 4

$OutputVar = Convert-AMPMhourTo24hour $AMPMhour -PM

Write-Host "$AMPMhour PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #2:"

Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM

$NowHour = Get-Date -UFormat %I
Write-Host "`$NowHour = $NowHour"

$OutputVar = (Get-Date -UFormat %I | Convert-AMPMhourTo24hour -PM)
Write-Host "`$OutputVar = $OutputVar"

Write-Host "$NowHour PM = $OutputVar           (24-hour)"
Write-Host "$(Get-Date -UFormat %I) PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

Write-Host `r`n

Write-Host "Example #3:"

Get-Random -Minimum 1 -Maximum 12 | Convert-AMPMhourTo24hour -PM

Get-Random -Minimum 1 -Maximum 12 | Tee-Object -Variable Randomvar | Convert-AMPMhourTo24hour -PM
Write-Host "`$Randomvar = $Randomvar"

$OutputVar = (Get-Random -Minimum 1 -Maximum 12 | Tee-Object -Variable Randomvar | Convert-AMPMhourTo24hour -PM)
Write-Host "$Randomvar PM = $OutputVar           (24-hour)"

Write-Host `r`n

#

Write-Host "--------------------------------------------------------------------------------------------------"

#

PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#2. User Choice Selection / Menu Demos
#=======================================================================================================================

$SectionName = "#2. User Choice Selection / Menu Demos"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------

Write-Host `r`n
Write-Host "User Choice Selection / Menu Demos"
Write-Host `r`n

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host 'Method #1: "Read-Host -Prompt"'
Write-HorizontalRuleAdv -HRtype DashedLine
do {
	$ChoiceYesNoCancel = Read-Host -Prompt "[Y]es, [N]o, or [C]ancel? [Y\N\C]"
	switch ($ChoiceYesNoCancel) {
		'Y'	{ # Y - Yes
			Write-Verbose "Yes ('$ChoiceYesNoCancel') option selected."
			Write-Host "Yes ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		'N' { # N - No
			Write-Verbose "No ('$ChoiceYesNoCancel') option selected."
			Write-Host "No ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		'C' { # C - Cancel
			Write-Verbose "Cancel ('$ChoiceYesNoCancel') option selected."
			Write-Host "Cancel ('$ChoiceYesNoCancel') option selected."
			Write-Host `r`n
		}
		default { # Choice not recognized.
			Write-Host `r`n
			Write-Host "Choice `"$ChoiceYesNoCancel`" not recognized. Options must be Yes, No, or Cancel."
			#Write-HorizontalRuleAdv -HRtype DashedLine
			Write-Host `r`n
			#Break #help about_Break
			PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
			Write-Host `r`n
			Write-HorizontalRuleAdv -HRtype DashedLine
		}
	}
}
until ($ChoiceYesNoCancel -eq 'Y' -Or $ChoiceYesNoCancel -eq 'N' -Or $ChoiceYesNoCancel -eq 'C')
Write-HorizontalRuleAdv -HRtype DashedLine
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `r`n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host 'Method #2: "PromptForChoice()"'
#-----------------------------------------------------------------------------------------------------------------------
# Build Menu
#-----------------------------------------------------------------------------------------------------------------------
#Clear-Host # CLS
Write-HorizontalRuleAdv -HRtype DashedLine
#-----------------------------------------------------------------------------------------------------------------------
# Build Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
$Title = "Main Menu"
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$Info = 'User choice selection example using "PromptForChoice()"'
$Info = @"
User choice selection example using "PromptForChoice()"

Y - Yes
N - No
Q - Quit
 
Select a choice:
"@
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# &Quit makes Q a Hot Key. 
$ChoiceYes = New-Object System.Management.Automation.Host.ChoiceDescription "&Yes", "Select [Y]es as the answer."
$ChoiceNo = New-Object System.Management.Automation.Host.ChoiceDescription "&No", "Select [N]o as the answer."
$ChoiceQuit = New-Object System.Management.Automation.Host.ChoiceDescription "&Quit", "[Q]uit, prints `"Good Bye!!!`" in green"
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
$Options = [System.Management.Automation.Host.ChoiceDescription[]]($ChoiceYes, $ChoiceNo)
# default choice: 0 = first Option, 1 = second option, etc.
[int]$defaultchoice = 1
#-----------------------------------------------------------------------------------------------------------------------
# Execute Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
# PromptForChoice() output will always be integer: https://powershell.org/forums/topic/question-regarding-result-host-ui-promptforchoice/
# If run from shell, will create a GUI dialog box. If run from script, will create choice text menu in command line.
# https://social.technet.microsoft.com/wiki/contents/articles/24030.powershell-demo-prompt-for-choice.aspx
$answer = $host.UI.PromptForChoice($Title, $Info, $Options, $defaultchoice)
#-----------------------------------------------------------------------------------------------------------------------
# Interpret answer
#-----------------------------------------------------------------------------------------------------------------------
#help about_switch
#https://powershellexplained.com/2018-01-12-Powershell-switch-statement/#switch-statement
Write-Verbose "Answer = $answer"
switch ($answer) {
	0	{ # Y - Yes
		Write-Verbose "Yes ('$answer') option selected."
		Write-Host "Si Senor." -ForegroundColor Green
		Write-Host `r`n
	}
	1 { # N - No
		Write-Verbose "No ('$answer') option selected."
		Write-Host "No gracias." -ForegroundColor Orange
		Write-Host `r`n
	}
	2 {
		Write-Verbose "Quit ('$answer') option selected."
		Write-Host "Good Bye!!!" -ForegroundColor Green
		Write-HorizontalRuleAdv -HRtype DashedLine
		Write-Host `r`n
	}
}
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `r`n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host 'Method #3: "Out-GridView -PassThru"'
Write-HorizontalRuleAdv -HRtype DashedLine
#-----------------------------------------------------------------------------------------------------------------------
# Build Menu
#-----------------------------------------------------------------------------------------------------------------------
Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Menu example using Out-GridView:"
#-----------------------------------------------------------------------------------------------------------------------
# Build Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
$Title = "Main Menu"
$Menu = [ordered]@{
	1 = 'Yes'
	2 = 'No'
	3 = 'Cancel'
}
#-----------------------------------------------------------------------------------------------------------------------
# Execute Choice Prompt
#-----------------------------------------------------------------------------------------------------------------------
# Using Out-GridView creates a GUI selection window with filter ability
# and ability to select multiple options with the -PassThru switch
$Result = $Menu | Out-GridView -PassThru -Title $Title
#-----------------------------------------------------------------------------------------------------------------------
# Interpret answer
#-----------------------------------------------------------------------------------------------------------------------
$answer = $Result.Name
Write-Verbose "`$Result.Name = $answer"
Write-HorizontalRuleAdv -HRtype DashedLine -IsVerbose
Switch ($answer) {
	1 {
		Write-Host '"Yes" was selected.'
	}
	2 {
		Write-Host '"No" was selected.'
	}
	3 {
		Write-Host '"Cancel" was selected.'
	}
}
Write-HorizontalRuleAdv -HRtype DashedLine
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#3. Test For loop & date formatting
#=======================================================================================================================

$SectionName = "#3. Test For loop & date formatting"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Months in 3 letters."
# https://www.business.com/articles/powershell-for-loop/
# help about_For
For ($m=1; $m -lt 13; $m++) {
    $m
    Get-Date -Month $m -UFormat %b
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#4. Test multi-dimensional variable methods
#=======================================================================================================================

$SectionName = "#4. Test multi-dimensional variable methods"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 1."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test1.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($column in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $column"
	Write-Host "Array One: $column[0]"
	Write-Host "Array Two: $column[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test2.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Test CSV ForEach loop 3."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
ForEach ($line in $CSVarray) {
	Write-Host "Start of loop."
    Write-Host "Whole:     $line"
	Write-Host "Array One: $line[0]"
	Write-Host "Array Two: $line[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test3.csv"
$CSVheaders = "col1,col2"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders | ForEach {
	Write-Host "Start of loop."
    Write-Host "Whole:     $_"
	Write-Host "Array One: $_[0]"
	Write-Host "Array Two: $_[1]"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype SingleLine
Write-Host `n
Write-Host "Test Import-CSV ForEach loop 2."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\test4.csv"
$CSVheaders = "col1,col2,col3"
$CSVarray = (Get-Content $CSVfile).split(",")
$CSVimport = Import-CSV -Path $CSVfile -Delimiter "," -Header $CSVheaders
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
Import-CSV -Path $CSVfile | ForEach {
	Write-Host "Start of loop."
    Write-Host "Whole:     $_"
	Write-Host "Col call: $($_."header 1")"
	Write-Host "Col call: $($_."header 2")"
	Write-Host "Col call: $($_.H1)"
	Write-Host "Col call: $($_."header 4")"
}
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-HorizontalRuleAdv -HRtype DoubleLine
Write-Host `n
Write-Host "Perform actions from a CSV file."
$CSVfile = "$Home\Documents\SodaLake\PowerShell\Templates\commands.csv"
$CSVheaders = "Program,Exec Command"
# check if file exists
Test-Path $CSVfile
If (-Not (Test-Path $CSVfile)) {
	Write-Warning "File does not exist: $CSVfile"
}
Write-Host `n
# https://www.business.com/articles/powershell-for-loop/
# help about_ForEach
# The foreach alias also supports beginning command blocks, middle command blocks, and end command blocks. The beginning and end command blocks run once, and the middle command block runs every time the Foreach loop steps through a collection or array.
# <command> | foreach {<beginning command_block>}{<middle command_block>}{<ending command_block>}
Import-CSV -Path $CSVfile | ForEach-Object {
	# beginning (runs once)
	Write-Host `n
	Write-Host "Beginning block: ForEach"
	Write-Host `n
}{
    # middle (loop)
	Write-Host "$_"
	
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-1/
	# https://discoposse.com/2012/01/23/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-2/
	# https://discoposse.com/2012/12/29/csv-yeah-you-know-me-powershell-and-the-import-csv-cmdlet-part-3/
	
	$HostProgram = $_.Program
	$CommandToExecute = $_."Exec Command"
	
	Write-Host "Host Program: $HostProgram"
	Write-Host "Expand Var: $($_.Program)"
	
	Write-Host "Command to execute: $CommandToExecute"
	Write-Host "Expand Var: $($_."Exec Command")"
	Write-Host `n
}{
	# ending (runs once)
	Write-Host "Ending block: ForEach"
	Write-Host `n
}

Write-Host "Loop is over."
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#=======================================================================================================================
#5. Test running external script
#=======================================================================================================================

$SectionName = "#5. Test running external script"

$ChoiceSkip = PromptForChoice-YesNoSectionSkip $SectionName

If ($ChoiceSkip -eq 'N') {
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#-----------------------------------------------------------------------------------------------------------------------

Write-Host `n
Write-HorizontalRuleAdv -HRtype DashedLine
Write-Host `n
Write-Host "Run External Script."
$ExternalScript = "$Home\Documents\SodaLake\PowerShell\Choice\DialogDemo.ps1"
PowerShell.exe -NoProfile -ExecutionPolicy Bypass -Command "& '$ExternalScript'"
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
}

#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

Write-Host `n
Write-Verbose "/Script body."
Write-HorizontalRuleAdv -HRtype DoubleLine
#Script MAIN Execution ends here
#
#
#
#- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#=======================================================================================================================
#-----------------------------------------------------------------------------------------------------------------------

#-----------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------[Footer]---------------------------------------------------------

Write-Host `n
Write-Host "End of script" $MyInvocation.MyCommand.Name
Write-Host `n
PAUSE # PAUSE (alias for Read-Host) Prints "Press Enter to continue...: "
Write-Host `n

Write-Verbose "Script Main end. $ScriptName"
Write-Debug "End-of-script. $ScriptName"
Write-LogInfo -LogPath $sLogFile -Message "End of script $ScriptName"
Stop-Log -LogPath $sLogFile
Write-Output $sLogFile
Return
